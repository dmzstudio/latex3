% \iffalse meta-comment
%
%% File: l3bitset.dtx
%
% Copyright (C) 2020 The LaTeX3 Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "l3bitset bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver>
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
% \title{^^A
%   The \pkg{l3bitset} package  \\ Bitsets ^^A
% }
%
% \author{^^A
%  The \LaTeX3 Project\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
% }
%
% \date{Released XXXX-XX-XX}
%
% \maketitle
% \begin{documentation}
%
% This package defines and implements the data type \texttt{bitset}, a vector of
% bits. The size of the vector may grow dynamically.
% Individual bits can be set and unset by index and by name.
% The index is like all other indices in expl3 modules \emph{1-based}.
% A \texttt{bitset} can be output as binary number or---as needed e.g. in a
% PDF dictionary---as decimal (arabic) number.
% Currently only a small subset of the functions provided by the \pkg{bitset}
% package are implemented here, mainly the functions needed to use bitsets in
% PDF dictionaries.
%
% The bitset is stored as a string (but one shouldn't rely on the internal
% representation) and so the vector size is theoretically
% unlimited, only restricted by \TeX-memory. But the export function
% \cs{bitset_to_arabic:N} can use functions from the \texttt{int} module only if
% the largest index used for this bitset is smaller then 32, for longer
% bitsets \texttt{fp} is used and this is slower.
%
% \section{Creating bitsets}
% \begin{function}[added = 2020-12-13]
%   {\bitset_new:N,\bitset_new:c}
%   \begin{syntax}
%     \cs{bitset_new:N}  \meta{bitset var} \\
%   \end{syntax}
% Creates a new \meta{bitset var} or raises an error if the name is already taken.
% The declaration is global. The \meta{bitset var} is initially 0.
%
%  Bitsets are implemented as string variables consisting of
%  \texttt{1}'s and \texttt{0}'s.
%  The rightmost number is the index position 1, so
%  the string variable can be viewed directly as the binary number.
%  But one shouldn't rely on the internal representation, but use the
%  dedicated \cs{bitset_to_bin:N} instead to get the binary number.
% \end{function}
%
% \begin{function}[EXP, pTF,added = 2020-12-14]
%   { \bitset_if_exist:N, \bitset_if_exist:c  }
%   \begin{syntax}
%     \cs{bitset_if_exist_p:N} \meta{bitset var}
%     \cs{bitset_if_exist:NTF} \meta{bitset var} \Arg{true code} \Arg{false code}%
%   \end{syntax}
%   Tests whether the \meta{bitset var} exist.
% \end{function}

%
% \section{Setting and unsetting bits}
%
% \begin{function}[added = 2020-12-13]
%   { \bitset_set_true:Nn, \bitset_set_true:cn, \bitset_gset_true:Nn, \bitset_gset_true:cn  }
%   \begin{syntax}
%     \cs{bitset_set_true:Nn}   \meta{bitset var}  \Arg{integer expression}\\
%     \cs{bitset_gset_true:Nn}  \meta{bitset var}  \Arg{integer expression}
%   \end{syntax}
% Evaluates the \meta{integer expression} and sets the bit of the
% index position it represents to 1. Index position are 1-based and set from
% right to left (so one can view the bitset as a binary number).
% If needed the length of the bit vector is enlarged.
% If the \meta{integer expression} evaluates to a negative number, nothing happens.
% \end{function}
%
% \begin{function}[added = 2020-12-13]
%   { \bitset_set_false:Nn, \bitset_set_false:cn, \bitset_gset_false:Nn, \bitset_set_false:cn }
%   \begin{syntax}
%     \cs{bitset_set_false:Nn}   \meta{bitset var}  \Arg{integer expression}\\
%     \cs{bitset_gset_false:Nn}  \meta{bitset var}  \Arg{integer expression}
%   \end{syntax}
% Evaluates the \meta{integer expression} and unsets the bit of the
% index position it represents (sets it to 0).
% The index is 1-based. If the \meta{integer expression} evaluates to a
% negative number or is larger than the current length of the bit vector
% nothing happens. If the leading (left most) bit is unset,
% zeros are not trimmed but stay in the bit vector.
% \end{function}
%
% \begin{function}[added = 2020-12-22]
%   {\bitset_clear:N,\bitset_clear:c,\bitset_gclear:N,\bitset_gclear:c}
%   \begin{syntax}
%     \cs{bitset_clear:N}  \meta{bitset var} \\
%     \cs{bitset_gclear:N}  \meta{bitset var}
%   \end{syntax}
% This resets the bitset to the initial state.
% \end{function}
%
% \section{Using bitsets}
%
% \begin{function}[EXP,added = 2020-12-14]
%   { \bitset_index:Nn, \bitset_index:cn }
%   \begin{syntax}
%     \cs{bitset_index:Nn}   \meta{bitset var}  \Arg{integer expression}
%   \end{syntax}
% Evaluates the \meta{integer expression} and output \texttt{1} if the bit is
% set and \texttt{0} otherwise.
% \end{function}
%
% \begin{function}[EXP,added = 2020-12-13]
%   {\bitset_to_bin:N, \bitset_to_bin:c}
%   \begin{syntax}
%     \cs{bitset_to_bin:N} \meta{bitset var}
%   \end{syntax}
% This leaves the current value of the bitset expressed as
% a binary (string) number in the input stream.
% If no bit has been set yet, the output is zero.
% \end{function}
% \begin{function}[EXP,added = 2020-12-13]
%   {\bitset_to_arabic:N, \bitset_to_arabic:c}
%   \begin{syntax}
%     \cs{bitset_to_arabic:N} \meta{bitset var}
%   \end{syntax}
% This leaves the current value of the bitset expressed as
% a decimal number in the input stream. If no bit has been set yet,
% the output is zero. The function uses \cs{int_from_bin:n} if the largest
% index that have been set or unset is smaller then 32, and a slower implementation
% based on \cs{fp_eval} otherwise.
% \end{function}
%
%
% \begin{function}[added = 2020-12-13]
%   {\bitset_show:N, \bitset_show:c}
%   \begin{syntax}
%     \cs{bitset_show:N} \meta{bitset var}
%   \end{syntax}
% Displays the binary and decimal value of the \meta{bitset var} on the terminal,
% \end{function}
%
% \begin{function}[added = 2020-12-13]
%   {\bitset_log:N, \bitset_log:c}
%   \begin{syntax}
%     \cs{bitset_log:N} \meta{bitset var}
%   \end{syntax}
% Writes the value of the \meta{bitset var} in the log file.
% \end{function}
%

% \section{Syntactic sugar: Setting bits by keys}
%
% \begin{function}[added = 2020-12-19]
%   {\bitset_gset_named_index:Nn}
%   \begin{syntax}
%     \cs{bitset_gset_named_index:Nn} \meta{bitset var}
%      \{
%         \meta{name1} |=| \meta{index1} |,|
%         \meta{name2} |=| \meta{index2} |,| \ldots{}
%      \}
%   \end{syntax}
% This adds the name--index pairs given in the second
% argument to an internal, global property list. If the
% property list didn't exist yet, it is created.
% It is then possible to use the names (the keys of the property
% to set and unset bits. It is not necessary to give every index
% a name, and an index can have more than one name.
% \end{function}
%
%  For example after this settings
%
%  \begin{verbatim}
%  \bitset_new:N \l_pdfannot_F_bitset
%  \bitset_gset_named_index:Nn \l_pdfannot_F_bitset
%    {
%      Invisible      = 1,
%      Hidden         = 2,
%      Print          = 3,
%      NoZoom         = 4,
%      NoRotate       = 5,
%      NoView         = 6,
%      ReadOnly       = 7,
%      Locked         = 8,
%      ToggleNoView   = 9,
%      LockedContents = 10
%    }
%  \end{verbatim}
%  it is possible to set bit 3 by using
%  |\bitset_set_true_key:Nn \l_pdfannot_F_bitset {Print}|
%  If a key is unknown a warning is issued.
% \begin{function}[added = 2020-12-13]
%   {\bitset_set_true_key:Nn, \bitset_set_true_key:cn,
%    \bitset_gset_true_key:Nn,\bitset_gset_true_key:cn }
%   \begin{syntax}
%     \cs{bitset_set_true_key:Nn}   \meta{bitset var}  \Arg{key}\\
%     \cs{bitset_gset_true_key:Nn}  \meta{bitset var}  \Arg{key}
%   \end{syntax}
% This sets the bit of the position described by key to \texttt{1}.
%
% If needed the length of the bitset is enlarged.
% \end{function}
% \begin{function}[added = 2020-12-13]
%   {\bitset_set_false_key:Nn, \bitset_set_false_key:cn,
%    \bitset_gset_false_key:Nn, \bitset_set_false_key:cn,}
%   \begin{syntax}
%     \cs{bitset_set_false_key:Nn}   \meta{bitset var}  \Arg{key}\\
%     \cs{bitset_gset_false_key:Nn}  \meta{bitset var}  \Arg{key}
%   \end{syntax}
% This sets the bit of the position described by key to 0.
% If the leading (left most) bit is unset, zeros are not
% trimmed but stay in the bit vector.
% \end{function}
% \begin{function}[EXP,added = 2020-12-14]
%   {\bitset_key:Nn}
%   \begin{syntax}
%     \cs{bitset_key:Nn}     \meta{bitset var}  \Arg{key}
%   \end{syntax}
% This outputs \texttt{1} if the bit is set, \texttt{0} otherwise.
% \end{function}
% \end{documentation}
%
% \begin{implementation}
% \section{\pkg{l3bitset} implementation}
% \TestFiles{m3bitset001,m3bitset002}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=bitset>
%    \end{macrocode}
% A bitset is a string variable.
%  \begin{macro}
%    {
%      \bitset_new:N,  \bitset_new:c
%    }
%    \begin{macrocode}
\cs_new_protected:Npn \bitset_new:N #1
  {
    \__kernel_chk_if_free_cs:N #1
    \cs_gset_eq:NN #1 \c_zero_str
  }

\cs_generate_variant:Nn \bitset_new:N {c}
%    \end{macrocode}
% \end{macro}
% \begin{macro}[pTF]
%   {
%     \bitset_if_exist:N, \bitset_if_exist:c
%   }
%
% Existence tests.
%    \begin{macrocode}
\prg_new_eq_conditional:NNn
  \bitset_if_exist:N \str_if_exist:N { p , T , F , TF }
\prg_new_eq_conditional:NNn
  \bitset_if_exist:c \str_if_exist:c
  { p , T , F , TF }
%    \end{macrocode}
% \end{macro}

% \begin{macro}
%   {
%     \bitset_set_true:Nn, \bitset_set_true:cn,
%     \bitset_gset_true:Nn, \bitset_gset_true:cn,
%   }
% A bit is set by either extending the string or by splitting it and
% then inserting an 1. It is not checked if the value was already 1.
%    \begin{macrocode}
% #1 name, #2 index (integer expression, 1-based)
\cs_new_protected:Npn \bitset_set_true:Nn #1 #2
  {
    \int_compare:nNnT {#2 } > { 0 }
      {
        \int_compare:nNnTF {\str_count:N #1 } < { #2  }
          {
            %extend the str
            \exp_args:NNe
            \str_put_left:Nn #1 { \prg_replicate:nn {  #2 - \str_count:N #1 -1 } {0} }
            \str_put_left:Nn #1 { 1 }
          }
          {
            %replace value
            \str_set:Nx #1
              {
                \str_range:Nnn #1 {1}{-1 - (#2)}
                1
                \str_range:Nnn #1 {1 -(#2)}{-1}
             }
          }
      }
  }

%#1 name, #2 index (integer expression,1-based)
\cs_new_protected:Npn \bitset_gset_true:Nn #1 #2
  {
    \int_compare:nNnT {#2 } > { 0 }
      {
        \int_compare:nNnTF {\str_count:N #1 } < { #2  }
          {
          %  %extend the str
            \exp_args:NNe
            \str_gput_left:Nn #1 { \prg_replicate:nn {  #2 - \str_count:N #1 -1 } {0} }
            \str_gput_left:Nn #1 { 1 }
          }
          {
            % replace the value
            \str_gset:Nx #1
              {
                \str_range:Nnn #1 {1}{-1 -(#2)}
                1
                \str_range:Nnn #1 {1 -(#2)}{-1}
              }
          }
      }
  }
\cs_generate_variant:Nn \bitset_set_true:Nn  {cn}
\cs_generate_variant:Nn \bitset_gset_true:Nn {cn}
%    \end{macrocode}
% \end{macro}

% \begin{macro}
%   {
%     \bitset_set_false:Nn,  \bitset_set_false:cn,
%     \bitset_gset_false:Nn, \bitset_gset_false:cn
%   }
% Unsetting a bit has only to do something if the string is longer than then index.
%    \begin{macrocode}
\cs_new_protected:Npn \bitset_set_false:Nn #1 #2  %#1 name, #2 index (1-based)
 {
   \int_compare:nNnT {#2 } > { 0 }
     {
       \int_compare:nNnT {\str_count:N #1 } > { #2 -1 }
         {
           % need to replace the str
           \str_set:Nx #1
             {
               \str_range:Nnn #1 {1}{-1 - (#2)}
                0
               \str_range:Nnn #1 { 1 - (#2)}{-1}
             }
         }
     }
 }

\cs_new_protected:Npn \bitset_gset_false:Nn #1 #2  %#1 name, #2 index (1-based)
 {
   \int_compare:nNnT {#2 } > { 0 }
     {
       \int_compare:nNnT {\str_count:N #1 } > { #2 -1 }
         {
           % need to replace the str
           \str_gset:Nx #1
             {
               \str_range:Nnn #1 {1}{-1 -(#2)}
                0
               \str_range:Nnn #1 {1 - (#2)}{-1}
             }
         }
     }
 }
\cs_generate_variant:Nn \bitset_set_false:Nn {cn}
\cs_generate_variant:Nn \bitset_gset_false:Nn {cn}
%    \end{macrocode}
%  \end{macro}
% \begin{macro}
%   {
%     \bitset_clear:N,  \bitset_clear:c,
%     \bitset_gclear:N, \bitset_gclear:c
%   }
%    \begin{macrocode}
\cs_new_protected:Npn \bitset_clear:N #1
  {
    \str_set_eq:NN #1 \c_zero_str
  }
\cs_new_protected:Npn \bitset_gclear:N #1
  {
    \str_gset_eq:NN #1 \c_zero_str
  }
\cs_generate_variant:Nn \bitset_clear:N {c}
\cs_generate_variant:Nn \bitset_gclear:N {c}
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \bitset_to_arabic:N, \bitset_to_arabic:c,
%     \bitset_to_bin:N,    \bitset_to_bin:c,
%   }
%   The naming of the commands follow the names in the \texttt{int} module.
%   \cs{bitset_to_arabic:N} uses \cs{int_from_bin:n} if the string is shorter
%   then 32 and  the slower \cs{fp_eval} for larger bitsets.
%
%    \begin{macrocode}
\cs_new:Npn \bitset_to_arabic:N #1
  {
    \int_compare:nNnTF { \str_count:N #1 } < {32}
      { \exp_args:No \int_from_bin:n {#1} }
      {
        \exp_after:wN \@@_to_int:nN \exp_after:wN 0
        #1 \q_recursion_tail \q_recursion_stop
      }
  }

\cs_new:Npn \@@_to_int:nN #1#2
  {
    \quark_if_recursion_tail_stop_do:Nn #2 {#1}
    \exp_args:Nf \@@_to_int:nN { \fp_eval:n { #1 * 2 + #2 } }
  }

\cs_new:Npn \bitset_to_bin:N #1
  {
    #1
  }

\cs_generate_variant:Nn \bitset_to_arabic:N  {c}
\cs_generate_variant:Nn \bitset_to_bin:N {c}
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \bitset_index:Nn, \bitset_index:cn
%   }
%    \begin{macrocode}
\cs_new:Npn \bitset_index:Nn #1 #2
  {
    \int_compare:nNnTF { #2 } > { 0 }
      {
        \int_eval:n { \str_item:Nn #1 { 0 - (#2)} + 0 }
      }
      {
        0
      }
  }
\cs_generate_variant:Nn \bitset_index:Nn {cn}
%    \end{macrocode}
% \end{macro}

% \begin{macro}
%   {
%     \bitset_show:N, \bitset_show:c,
%     \bitset_log:N,  \bitset_log:c
%   }
%    \begin{macrocode}
\cs_new_protected:Npn   \bitset_show:N { \@@_show:NN \msg_show:nnxxxx }
\cs_generate_variant:Nn \bitset_show:N { c }
\cs_new_protected:Npn   \bitset_log:N  { \@@_show:NN \msg_log:nnxxxx }
\cs_generate_variant:Nn \bitset_log:N  { c }
\cs_new_protected:Npn \__bitset_show:NN #1#2
  {
    \__kernel_chk_defined:NT #2
      {
        #1 { LaTeX/kernel } { show-bitset }
           { \token_to_str:N #2 }
           { \bitset_to_bin:N #2  }
           { \bitset_to_arabic:N #2  }
           { }
      }
  }

%    \end{macrocode}
% \end{macro}
% \begin{macro}
%  {
%    \bitset_gset_named_index:Nn
%  }
%    \begin{macrocode}
\cs_new_protected:Npn  \bitset_gset_named_index:Nn #1 #2
  {
     \prop_if_exist:cF { g_@@_\cs_to_str:N #1 _key_prop }
       {
         \prop_new:c { g_@@_\cs_to_str:N #1 _key_prop }
       }
     \prop_gset_from_keyval:cn
       { g_@@_\cs_to_str:N #1 _key_prop }
       { #2 }
  }
%    \end{macrocode}
% \begin{macro}
%   {
%     \bitset_set_true_key:Nn, \bitset_set_true_key:cn,
%     \bitset_gset_true_key:Nn, \bitset_gset_true_key:cn
%   }
%    \begin{macrocode}
\cs_new_protected:Npn \bitset_set_true_key:Nn #1 #2
  {
    \prop_if_in:cnTF { g_@@_\cs_to_str:N #1 _key_prop } {#2}
      {
        \bitset_set_true:Nn #1
          {
            \prop_item:cn{ g_@@_\cs_to_str:N #1 _key_prop }{#2}
          }
      }
      {
        \__kernel_msg_warning:nnxx { kernel } { bitset-unknown-key }
          { \token_to_str:N #1 }
          { \tl_to_str:n { #2} }
      }
  }

\cs_new_protected:Npn \bitset_gset_true_key:Nn #1 #2
  {
    \prop_if_in:cnTF { g_@@_\cs_to_str:N #1 _key_prop } {#2}
      {
        \bitset_gset_true:Nn #1
          {
            \prop_item:cn{ g_@@_\cs_to_str:N #1 _key_prop }{#2}
          }
      }
      {
         \__kernel_msg_warning:nnxx { kernel } { bitset-unknown-key }
           { \token_to_str:N #1 }
           { \tl_to_str:n { #2} }

      }
  }
\cs_generate_variant:Nn \bitset_set_true_key:Nn {cn}
\cs_generate_variant:Nn \bitset_gset_true_key:Nn {cn}

%    \end{macrocode}
% \end{macro}%
% \begin{macro}
%   {
%     \bitset_set_false_key:Nn,  \bitset_set_false_key:cn,
%     \bitset_gset_false_key:Nn, \bitset_gset_false_key:cn,
%   }
%    \begin{macrocode}
\cs_new_protected:Npn \bitset_set_false_key:Nn #1 #2
  {
    \prop_if_in:cnTF { g_@@_\cs_to_str:N #1 _key_prop } {#2}
      {
        \bitset_set_false:Nn #1
          {
            \prop_item:cn{ g_@@_\cs_to_str:N #1 _key_prop }{#2}
          }
      }
      {
        \__kernel_msg_warning:nnxx { kernel } { bitset-unknown-key }
          { \token_to_str:N #1 }
          { \tl_to_str:n { #2} }
      }
  }

\cs_new_protected:Npn \bitset_gset_false_key:Nn #1 #2
  {
    \prop_if_in:cnTF { g_@@_\cs_to_str:N #1 _key_prop } {#2}
      {
        \bitset_gset_false:Nn #1
          {
            \prop_item:cn{ g_@@_\cs_to_str:N #1 _key_prop }{#2}
          }
      }
      {
        \__kernel_msg_warning:nnxx { kernel } { bitset-unknown-key }
          { \token_to_str:N #1 }
          { \tl_to_str:n { #2} }
      }
  }
\cs_generate_variant:Nn \bitset_set_false_key:Nn {cn}
\cs_generate_variant:Nn \bitset_gset_false_key:Nn {cn}
%    \end{macrocode}
%  \end{macro}
% \begin{macro}
%   {
%     \bitset_key:Nn, \bitset_key:cn
%   }
%    \begin{macrocode}
\cs_new:Npn \bitset_key:Nn #1 #2
  {
    \prop_if_in:cnTF { g_@@_\cs_to_str:N #1 _key_prop } {#2}
      {
        \int_eval:n
          {
            \str_item:Nn #1
              { 0 - ( \prop_item:cn { g_@@_\cs_to_str:N #1 _key_prop }{#2} ) }
            +0
          }
     }
     {
       0
     }
  }
\cs_generate_variant:Nn \bitset_key:Nn  {cn}
%    \end{macrocode}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{macro}%
% \end{implementation}
%
% \PrintIndex
